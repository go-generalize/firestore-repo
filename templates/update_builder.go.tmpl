// Code generated by firestore-repo. DO NOT EDIT.
// generated version: {{ .AppVersion }}
package {{ .PackageName }}

import (
	"reflect"
	"strings"

	"cloud.google.com/go/firestore"
)

// UpdateBuilder - update builder
type UpdateBuilder struct {
	Path  string
	Value interface{}
}

// NewUpdater - constructor
func NewUpdater(v interface{}) *UpdateBuilder {
	return &UpdateBuilder{
		Value: v,
	}
}

// Update - firestore.Update
func (ub *UpdateBuilder) Update(path string) firestore.Update {
	return firestore.Update{
		Path:  path,
		Value: ub.Value,
	}
}

func getUpdateParams(v interface{}, meta ...map[string]string) (updates []firestore.Update) {
	metaMap := make(map[string]string)
	if len(meta) > 0 {
		metaMap = meta[0]
	}
	rv := reflect.Indirect(reflect.ValueOf(v))
	rt := rv.Type()
	if !strings.HasSuffix(rt.Name(), "UpdateParam") {
		return updates
	}
	updates = make([]firestore.Update, 0, rt.NumField())
	for i := 0; i < rt.NumField(); i++ {
		f := rt.Field(i)

		fv := rv.Field(i)
		if fv.Kind() == reflect.String {
			continue
		} else if fv.IsNil() {
			continue
		}

		m := fv.MethodByName("Update")
		if !m.IsValid() {
			continue
		}

		tag, ok := f.Tag.Lookup("firestore")
		if !ok && len(metaMap) > 0 {
			if _, ok = metaMap[f.Name]; ok {
				tag = metaMap[f.Name]
			}
		}

		rets := m.Call([]reflect.Value{reflect.ValueOf(tag)})
		if len(rets) == 0 {
			continue
		}

		ret := rets[0]
		if !ret.CanInterface() {
			continue
		}

		update, ok := ret.Interface().(firestore.Update)
		if !ok {
			continue
		}
		updates = append(updates, update)
	}
	return updates
}
