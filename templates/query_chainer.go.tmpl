// THIS FILE IS A GENERATED CODE. DO NOT EDIT
// generated version: {{ .AppVersion }}
package {{ .PackageName }}

import (
	"time"

	"cloud.google.com/go/firestore"
	"github.com/go-utils/dedupe"
	"golang.org/x/xerrors"
	"google.golang.org/genproto/googleapis/type/latlng"
)

// QueryChainer ...
type QueryChainer struct {
	QueryGroup []*Query
	err        error
}

// NewQueryChainer - constructor
func NewQueryChainer() *QueryChainer {
	return new(QueryChainer)
}

// Equal - change operator
func (qc *QueryChainer) Equal(v interface{}) *QueryChainer {
	q, err := newQuery(v, OpTypeEqual)
	if err != nil {
		qc.err = err
		return qc
	}
	qc.QueryGroup = append(qc.QueryGroup, q)
	return qc
}

// NotEqual - change operator
func (qc *QueryChainer) NotEqual(v interface{}) *QueryChainer {
	q, err := newQuery(v, OpTypeNotEqual)
	if err != nil {
		qc.err = err
		return qc
	}
	qc.QueryGroup = append(qc.QueryGroup, q)
	return qc
}

// LessThan - change operator
func (qc *QueryChainer) LessThan(v interface{}) *QueryChainer {
	q, err := newQuery(v, OpTypeLessThan)
	if err != nil {
		qc.err = err
		return qc
	}
	qc.QueryGroup = append(qc.QueryGroup, q)
	return qc
}

// LessThanOrEqual - change operator
func (qc *QueryChainer) LessThanOrEqual(v interface{}) *QueryChainer {
	q, err := newQuery(v, OpTypeLessThanOrEqual)
	if err != nil {
		qc.err = err
		return qc
	}
	qc.QueryGroup = append(qc.QueryGroup, q)
	return qc
}

// GreaterThan - change operator
func (qc *QueryChainer) GreaterThan(v interface{}) *QueryChainer {
	q, err := newQuery(v, OpTypeGreaterThan)
	if err != nil {
		qc.err = err
		return qc
	}
	qc.QueryGroup = append(qc.QueryGroup, q)
	return qc
}

// GreaterThanOrEqual - change operator
func (qc *QueryChainer) GreaterThanOrEqual(v interface{}) *QueryChainer {
	q, err := newQuery(v, OpTypeGreaterThanOrEqual)
	if err != nil {
		qc.err = err
		return qc
	}
	qc.QueryGroup = append(qc.QueryGroup, q)
	return qc
}

// In - change operator
func (qc *QueryChainer) In(v interface{}) *QueryChainer {
	q, err := newQuery(v, OpTypeIn)
	if err != nil {
		qc.err = err
		return qc
	}
	qc.QueryGroup = append(qc.QueryGroup, q)
	return qc
}

// ArrayContains - change operator
func (qc *QueryChainer) ArrayContains(v interface{}) *QueryChainer {
	q, err := newQuery(v, OpTypeArrayContains)
	if err != nil {
		qc.err = err
		return qc
	}
	qc.QueryGroup = append(qc.QueryGroup, q)
	return qc
}

// ArrayContainsAny - change operator
func (qc *QueryChainer) ArrayContainsAny(v interface{}) *QueryChainer {
	q, err := newQuery(v, OpTypeArrayContainsAny)
	if err != nil {
		qc.err = err
		return qc
	}
	qc.QueryGroup = append(qc.QueryGroup, q)
	return qc
}

// Error - error
func (qc *QueryChainer) Error() error {
	return qc.err
}

// Query ...
type Query struct {
	Operator OpType
	Value    interface{}
}

func newQuery(v interface{}, opType OpType) (*Query, error) {
	dupErr := func(err error) (*Query, error) {
		return nil, xerrors.Errorf("failed to deduplication: %w", err)
	}
	switch x := v.(type) {
	case []bool:
		if err := dedupe.Do(&x); err != nil {
			return dupErr(err)
		}
		v = x
	case []string:
		if err := dedupe.Do(&x); err != nil {
			return dupErr(err)
		}
		v = x
	case []int:
		if err := dedupe.Do(&x); err != nil {
			return dupErr(err)
		}
		v = x
	case []int64:
		if err := dedupe.Do(&x); err != nil {
			return dupErr(err)
		}
		v = x
	case []float64:
		if err := dedupe.Do(&x); err != nil {
			return dupErr(err)
		}
		v = x
	case []*latlng.LatLng:
		if err := dedupe.Do(&x); err != nil {
			return dupErr(err)
		}
		v = x
	case []*firestore.DocumentRef:
		if err := dedupe.Do(&x); err != nil {
			return dupErr(err)
		}
		v = x
	case bool,
		string,
		int,
		int64,
		float64,
		*latlng.LatLng,
		*firestore.DocumentRef,
		map[string]bool,
		map[string]string,
		map[string]int,
		map[string]int64,
		map[string]float64:
		// ok
	case time.Time:
		v = SetLastThreeToZero(x)
	case []time.Time:
		after := make([]time.Time, len(x))
		for n, t := range x {
			after[n] = SetLastThreeToZero(t)
		}
		v = after
	default:
		return nil, xerrors.Errorf("unsupported types: %#v", v)
	}

	q := &Query{
		Operator: opType,
		Value:    v,
	}
	return q, nil
}

// IsSlice ...
func IsSlice(v interface{}) bool {
	switch v.(type) {
	case []bool, []string, []int, []int64, []float64,
		[]*latlng.LatLng, []*firestore.DocumentRef:
		return true
	}
	return false
}

// IsSlice ...
func (q *Query) IsSlice() bool {
	return IsSlice(q.Value)
}
