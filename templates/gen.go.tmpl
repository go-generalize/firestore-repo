// THIS FILE IS A GENERATED CODE. DO NOT EDIT
// generated version: {{ .AppVersion }}
package {{ .PackageName }}

import (
	"context"
{{- if .MetaFields }}
	"time"
{{- end }}

	"cloud.google.com/go/firestore"
	"github.com/go-utils/dedupe"
	"golang.org/x/xerrors"
	"google.golang.org/api/iterator"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)
{{ $generate := "go:generate" }}
//{{ $generate }} mockgen -source {{ .GeneratedFileName }}.go -destination mock/mock_{{ .GeneratedFileName }}/mock_{{ .GeneratedFileName }}.go

// {{ .RepositoryInterfaceName }} Repository of {{ .StructName }}
type {{ .RepositoryInterfaceName }} interface {
	// Single
	{{ GetFunc }}
	{{ GetWithDocFunc }}
	{{ InsertFunc }}
	{{ UpdateFunc }}
	{{ DeleteFunc }}
	{{ DeleteByFunc }}
	// Multiple
	{{ GetMultiFunc }}
	{{ InsertMultiFunc }}
	{{ UpdateMultiFunc }}
	{{ DeleteMultiFunc }}
	{{ DeleteMultiByFunc }}
	// Transaction
	{{ GetWithTxFunc }}
	{{ GetWithDocWithTxFunc }}
	{{ InsertWithTxFunc }}
	{{ UpdateWithTxFunc }}
	{{ DeleteWithTxFunc }}
	{{ DeleteByWithTxFunc }}
	// List
	{{ ListFunc }}
	{{ ListWithTxFunc }}
	// misc
	GetCollection() *firestore.CollectionRef
	GetCollectionName() string
	GetDocRef(id string) *firestore.DocumentRef
}
{{ $middlewareName := printf "%sMiddleware" .RepositoryInterfaceName }}
// {{ $middlewareName }} middleware of {{ .RepositoryInterfaceName }}
type {{ $middlewareName }} interface {
	BeforeInsert(ctx context.Context, subject *{{ .StructName }}) (bool, error)
	BeforeUpdate(ctx context.Context, old, subject *{{ .StructName }}) (bool, error)
	BeforeDelete(ctx context.Context, subject *{{ .StructName }}, opts ...DeleteOption) (bool, error)
	BeforeDeleteBy{{ .KeyFieldName }}(ctx context.Context, {{ PluralForm .KeyValueName }} []{{ .KeyFieldType }}, opts ...DeleteOption) (bool, error)
}

type {{ .RepositoryStructName }} struct {
	collectionName  string
	firestoreClient *firestore.Client{{ if eq .IsSubCollection true }}
	parentDocument  *firestore.DocumentRef{{ end }}
	middleware      []{{ $middlewareName }}
}

// New{{ .RepositoryInterfaceName }} constructor
func New{{ .RepositoryInterfaceName }}(firestoreClient *firestore.Client{{ if eq .IsSubCollection true }}, parentDocument *firestore.DocumentRef{{ end }}, middleware ...{{ $middlewareName }}) {{ .RepositoryInterfaceName }} {
	return &{{ .RepositoryStructName }}{
		collectionName:  "{{ .StructName }}",
		firestoreClient: firestoreClient,{{ if eq .IsSubCollection true }}
		parentDocument:  parentDocument,{{ end }}
		middleware:      middleware,
	}
}
{{ if .MetaFields }}
func (repo *{{ .RepositoryStructName }}) setMeta(subject *{{ .StructName }}, isInsert bool) {
	now := time.Now()

	if isInsert {
		subject.CreatedAt = time.Now()
	}
	subject.UpdatedAt = now
	subject.Version++
}
{{ end }}
func (repo *{{ .RepositoryStructName }}) beforeInsert(ctx context.Context, subject *{{ .StructName }}) error {
{{- if .MetaFields }}
	if subject.Version != 0 {
		return xerrors.Errorf("insert data must be Version == 0: %+v", subject)
	}
	if subject.DeletedAt != nil {
		return xerrors.Errorf("insert data must be DeletedAt == nil: %+v", subject)
	}
	repo.setMeta(subject, true)
{{ end }}
	for _, m := range repo.middleware {
		c, err := m.BeforeInsert(ctx, subject)
		if err != nil {
			return xerrors.Errorf("beforeInsert.middleware error: %w", err)
		}
		if !c {
			continue
		}
	}
	return nil
}

func (repo *{{ .RepositoryStructName }}) beforeUpdate(ctx context.Context, old, subject *{{ .StructName }}) error {
{{- if .MetaFields }}
	if old.Version > subject.Version {
		return xerrors.Errorf("The data in the database is newer: (db version: %d, target version: %d) %+v",
			old.Version, subject.Version, subject)
	}
	if subject.DeletedAt != nil {
		return xerrors.Errorf("update data must be DeletedAt == nil: %+v", subject)
	}
	repo.setMeta(subject, false)
{{ end }}
	for _, m := range repo.middleware {
		c, err := m.BeforeUpdate(ctx, old, subject)
		if err != nil {
			return xerrors.Errorf("beforeUpdate.middleware error: %w", err)
		}
		if !c {
			continue
		}
	}
	return nil
}

func (repo *{{ .RepositoryStructName }}) before{{ DeleteFunc }} {
{{- if .MetaFields }}
	repo.setMeta(subject, false)
{{ end }}
	for _, m := range repo.middleware {
		c, err := m.BeforeDelete(ctx, subject, opts...)
		if err != nil {
			return xerrors.Errorf("beforeDelete.middleware error: %w", err)
		}
		if !c {
			continue
		}
	}
	return nil
}

// GetCollection *firestore.CollectionRef getter
func (repo *{{ .RepositoryStructName }}) GetCollection() *firestore.CollectionRef {
	return repo.{{ if eq .IsSubCollection true }}parentDocument{{ else }}firestoreClient{{ end }}.Collection(repo.collectionName)
}

// GetCollectionName CollectionName getter
func (repo *{{ .RepositoryStructName }}) GetCollectionName() string {
	return repo.collectionName
}

// GetDocRef *firestore.DocumentRef getter
func (repo *{{ .RepositoryStructName }}) GetDocRef(id string) *firestore.DocumentRef {
	return repo.GetCollection().Doc(id)
}
{{ $MetaName := .OmitMetaName }}
// {{ .StructName }}ListReq List取得時に渡すリクエスト
// └─ bool/int(64)|float64 は stringの独自型で渡す(BoolCriteria | NumericCriteria)
type {{ .StructName }}ListReq struct {
{{- range .FieldInfos }}
{{- if ne $MetaName .Field }}
	{{ .Field }}{{ .Space }} *QueryChainer
{{- end }}
{{- end }}
{{- if .MetaFields }}
{{- range $key, $value := .MetaFields }}
	{{ $key }}{{ $value.Space }} *QueryChainer
{{- end }}

	IncludeSoftDeleted bool
{{- end  }}
}

// List firestore.Queryを使用し条件抽出をする
//  └─ 第3引数はNOT/OR/IN/RANGEなど、より複雑な条件を適用したいときにつける
//      └─ 基本的にnilを渡せば良い
// BUG(54m) 潜在的なバグがあるかもしれない
func (repo *{{ .RepositoryStructName }}) {{ ListFunc }} {
	return repo.list(ctx, req, q)
}

// Get 処理中の {{ .StructName }} の取得処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) {{ GetFunc }} {
	doc := repo.GetDocRef({{ .KeyValueName }})
	return repo.get(ctx, doc, opts...)
}

// GetWithDoc 処理中の {{ .StructName }} の取得処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) {{ GetWithDocFunc }} {
	return repo.get(ctx, doc, opts...)
}

// Insert 処理中の {{ .StructName }} の登録処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) {{ InsertFunc }} {
	if err := repo.beforeInsert(ctx, subject); err != nil {
		return "", xerrors.Errorf("before insert error: %w", err)
	}
	return repo.insert(ctx, subject)
}

// Update 処理中の {{ .StructName }} の更新処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) {{ UpdateFunc }} {
	doc := repo.GetDocRef(subject.{{ .KeyFieldName }})

	old, err := repo.get(ctx, doc)
	if err != nil {
		if status.Code(err) == codes.NotFound {
			return ErrNotFound
		}
		return xerrors.Errorf("error in Get method: %w", err)
	}

	if err = repo.beforeUpdate(ctx, old, subject); err != nil {
		return xerrors.Errorf("before update error: %w", err)
	}

	return repo.update(ctx, subject)
}

// Delete 処理中の {{ .StructName }} の削除処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) {{ DeleteFunc }} {
	if err := repo.beforeDelete(ctx, subject, opts...); err != nil {
		return xerrors.Errorf("before delete error: %w", err)
	}

	return repo.deleteBy{{ .KeyFieldName }}(ctx, subject.{{ .KeyFieldName }}, opts...)
}

// DeleteBy{{ .KeyFieldName }} 処理中の {{ .StructName }} の{{ .KeyFieldName }}から削除処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) {{ DeleteByFunc }} {
	return repo.deleteBy{{ .KeyFieldName }}(ctx, {{ .KeyValueName }}, opts...)
}

// GetMulti 処理中の {{ .StructName }} の一括取得処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) {{ GetMultiFunc }} {
	collect := repo.GetCollection()
	docRefs := make([]*firestore.DocumentRef, 0, len({{ PluralForm .KeyValueName }}))
	for _, {{ .KeyValueName }} := range {{ PluralForm .KeyValueName }} {
		ref := collect.Doc({{ .KeyValueName }})
		docRefs = append(docRefs, ref)
	}

	snapShots, err := repo.firestoreClient.GetAll(ctx, docRefs)
	if err != nil {
		return nil, xerrors.Errorf("error in GetAll method: %w", err)
	}

	subjects := make([]*{{ .StructName }}, 0, len({{ PluralForm .KeyValueName }}))
	for _, snapShot := range snapShots {
		subject := new({{ .StructName }})
		if err := snapShot.DataTo(&subject); err != nil {
			return nil, xerrors.Errorf("error in DataTo method: %w", err)
		}
{{ if .MetaFields }}
		if len(opts) == 0 || !opts[0].IncludeSoftDeleted {
			if subject.DeletedAt != nil {
				continue
			}
		}
{{- end }}
		subject.{{ .KeyFieldName }} = snapShot.Ref.ID
		subjects = append(subjects, subject)
	}

	return subjects, nil
}

// InsertMulti 処理中の {{ .StructName }} の一括挿入処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) {{ InsertMultiFunc }} {
	{{ PluralForm .KeyValueName }} := make([]{{ .KeyFieldType }}, 0, len(subjects))
	batches := make([]*firestore.WriteBatch, 0)
	batch := repo.firestoreClient.Batch()
	collect := repo.GetCollection()

	for i, subject := range subjects {
{{- if .MetaFields }}
		err := repo.beforeInsert(ctx, subject)
		if err != nil {
			return nil, xerrors.Errorf("before insert error: %w", err)
		}

{{- end }}
		var ref *firestore.DocumentRef
		if subject.{{ .KeyFieldName }} == "" {
			ref = collect.NewDoc()
			subject.{{ .KeyFieldName }} = ref.ID
		} else {
			ref = collect.Doc(subject.{{ .KeyFieldName }})
			if s, err := ref.Get(ctx); err == nil {
				return nil, xerrors.Errorf("already exists [%v]: %#v", subject.{{ .KeyFieldName }}, s)
			}
		}
		batch.Set(ref, subject)
		{{ PluralForm .KeyValueName }} = append({{ PluralForm .KeyValueName }}, ref.ID)
		i++
		if (i%500) == 0 && len(subjects) != i {
			batches = append(batches, batch)
			batch = repo.firestoreClient.Batch()
		}
	}
	batches = append(batches, batch)

	for _, b := range batches {
		if _, err := b.Commit(ctx); err != nil {
			return nil, xerrors.Errorf("error in Commit method: %w", err)
		}
	}

	return {{ PluralForm .KeyValueName }}, nil
}

// UpdateMulti 処理中の {{ .StructName }} の一括更新処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) {{ UpdateMultiFunc }} {
	batches := make([]*firestore.WriteBatch, 0)
	batch := repo.firestoreClient.Batch()
	collect := repo.GetCollection()

	for i, subject := range subjects {
		ref := collect.Doc(subject.{{ .KeyFieldName }})
		{{ if .MetaFields }}snapShot{{ else }}_{{ end }}, err := ref.Get(ctx)
		if err != nil {
			if status.Code(err) == codes.NotFound {
				return xerrors.Errorf("not found [%v]: %w", subject.{{ .KeyFieldName }}, err)
			}
			return xerrors.Errorf("error in Get method [%v]: %w", subject.{{ .KeyFieldName }}, err)
		}
{{ if .MetaFields }}
		old := new({{ .StructName }})
		if err = snapShot.DataTo(&old); err != nil {
			return xerrors.Errorf("error in DataTo method: %w", err)
		}

		if err = repo.beforeUpdate(ctx, old, subject); err != nil {
			return xerrors.Errorf("before update error: %w", err)
		}
{{ end }}
		batch.Set(ref, subject)
		i++
		if (i%500) == 0 && len(subjects) != i {
			batches = append(batches, batch)
			batch = repo.firestoreClient.Batch()
		}
	}
	batches = append(batches, batch)

	for _, b := range batches {
		if _, err := b.Commit(ctx); err != nil {
			return xerrors.Errorf("error in Commit method: %w", err)
		}
	}

	return nil
}

// DeleteMulti 処理中の {{ .StructName }} の一括削除処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) {{ DeleteMultiFunc }} {
	batches := make([]*firestore.WriteBatch, 0)
	batch := repo.firestoreClient.Batch()
	collect := repo.GetCollection()

	for i, subject := range subjects {
		ref := collect.Doc(subject.{{ .KeyFieldName }})
		if _, err := ref.Get(ctx); err != nil {
			if status.Code(err) == codes.NotFound {
				return xerrors.Errorf("not found [%v]: %w", subject.{{ .KeyFieldName }}, err)
			}
			return xerrors.Errorf("error in Get method [%v]: %w", subject.{{ .KeyFieldName }}, err)
		}

		if err := repo.beforeDelete(ctx, subject, opts...); err != nil {
			return xerrors.Errorf("before delete error: %w", err)
		}
{{- if .MetaFields }}

		if len(opts) > 0 && opts[0].Mode == DeleteModeSoft {
			t := time.Now()
			subject.DeletedAt = &t
			batch.Set(ref, subject)
		} else {
			batch.Delete(ref)
		}
{{- else }}
		batch.Delete(ref)
{{ end }}
		i++
		if (i%500) == 0 && len(subjects) != i {
			batches = append(batches, batch)
			batch = repo.firestoreClient.Batch()
		}
	}
	batches = append(batches, batch)

	for _, b := range batches {
		if _, err := b.Commit(ctx); err != nil {
			return xerrors.Errorf("error in Commit method: %w", err)
		}
	}

	return nil
}

// DeleteMultiBy{{ PluralForm .KeyFieldName }} 処理中の {{ .StructName }} の{{ .KeyFieldName }}群を元に一括削除処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) {{ DeleteMultiByFunc }} {
	subjects := make([]*{{ .StructName }}, 0, len({{ PluralForm .KeyValueName }}))

	for _, {{ .KeyValueName }} := range {{ PluralForm .KeyValueName }} {
		subjects = append(subjects, &{{ .StructName }}{ {{- .KeyFieldName }}: {{ .KeyValueName }}})
	}

	return repo.DeleteMulti(ctx, subjects, opts...)
}

func (repo *{{ .RepositoryStructName }}) {{ ListWithTxFunc }} {
	return repo.list(tx, req, q)
}

// GetWithTx トランザクション中の {{ .StructName }} の取得処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) {{ GetWithTxFunc }} {
	doc := repo.GetDocRef({{ .KeyValueName }})
	return repo.get(tx, doc, opts...)
}

// GetWithDocWithTx トランザクション中の {{ .StructName }} の取得処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) {{ GetWithDocWithTxFunc }} {
	return repo.get(tx, doc, opts...)
}

// InsertWithTx トランザクション中の {{ .StructName }} の登録処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) {{ InsertWithTxFunc }} {
	if err := repo.beforeInsert(ctx, subject); err != nil {
		return "", xerrors.Errorf("before insert error: %w", err)
	}

	return repo.insert(tx, subject)
}

// UpdateWithTx トランザクション中の {{ .StructName }} の更新処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) {{ UpdateWithTxFunc }} {
	doc := repo.GetDocRef(subject.{{ .KeyFieldName }})
	old, err := repo.get(tx, doc)
	if err != nil {
		if status.Code(err) == codes.NotFound {
			return ErrNotFound
		}
		return xerrors.Errorf("error in Get method: %w", err)
	}

	if err = repo.beforeUpdate(ctx, old, subject); err != nil {
		return xerrors.Errorf("before update error: %w", err)
	}

	return repo.update(tx, subject)
}

// DeleteWithTx トランザクション中の {{ .StructName }} の削除処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) {{ DeleteWithTxFunc }} {
	if err := repo.beforeDelete(ctx, subject, opts...); err != nil {
		return xerrors.Errorf("before delete error: %w", err)
	}

	return repo.deleteBy{{ .KeyFieldName }}(tx, subject.{{ .KeyFieldName }}, opts...)
}

// DeleteBy{{ .KeyFieldName }}WithTx トランザクション中の {{ .StructName }} の削除処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) {{ DeleteByWithTxFunc }} {
	return repo.deleteBy{{ .KeyFieldName }}(tx, {{ .KeyValueName }}, opts...)
}

func (repo *{{ .RepositoryStructName }}) get(v interface{}, doc *firestore.DocumentRef, {{ MetaJudgment }} ...GetOption) (*{{ .StructName }}, error) {
	var (
		snapShot *firestore.DocumentSnapshot
		err      error
	)

	switch x := v.(type) {
	case *firestore.Transaction:
		snapShot, err = x.Get(doc)
	case context.Context:
		snapShot, err = doc.Get(x)
	default:
		return nil, xerrors.Errorf("invalid type: %v", x)
	}

	if err != nil {
		if status.Code(err) == codes.NotFound {
			return nil, ErrNotFound
		}
		return nil, xerrors.Errorf("error in Get method: %w", err)
	}

	subject := new({{ .StructName }})
	if err := snapShot.DataTo(&subject); err != nil {
		return nil, xerrors.Errorf("error in DataTo method: %w", err)
	}
{{ if .MetaFields }}
	if len(opts) == 0 || !opts[0].IncludeSoftDeleted {
		if subject.DeletedAt != nil {
			return nil, ErrAlreadyDeleted
		}
	}
{{- end }}
	subject.{{ .KeyFieldName }} = snapShot.Ref.ID

	return subject, nil
}

func (repo *{{ .RepositoryStructName }}) insert(v interface{}, subject *{{ .StructName }}) ({{ .KeyFieldType }}, error) {
	var (
{{- if .AutomaticGeneration }}
		dr  = repo.GetCollection().NewDoc()
{{- else }}
		dr  = repo.GetDocRef(subject.{{ .KeyFieldName }})
{{- end }}
		err error
	)

	switch x := v.(type) {
	case *firestore.Transaction:
{{- 	if .AutomaticGeneration }}
		if _, err = x.Get(dr); err == nil {
			return "", ErrAlreadyExists
		}
{{- 	end }}
		err = x.Set(dr, subject)
	case context.Context:
{{- 	if .AutomaticGeneration }}
		if _, err = dr.Get(x); err == nil {
			return "", ErrAlreadyExists
		}
{{- 	end }}
		_, err = dr.Set(x, subject)
	default:
		return "", xerrors.Errorf("invalid type: %v", v)
	}

	if err != nil {
		return "", xerrors.Errorf("error in Set method: %w", err)
	}

	subject.{{ .KeyFieldName }} = dr.ID

	return dr.ID, nil
}

func (repo *{{ .RepositoryStructName }}) update(v interface{}, subject *{{ .StructName }}) error {
	var (
		dr  = repo.GetDocRef(subject.{{ .KeyFieldName }})
		err error
	)

	switch x := v.(type) {
	case *firestore.Transaction:
		err = x.Set(dr, subject)
	case context.Context:
		_, err = dr.Set(x, subject)
	default:
		return xerrors.Errorf("invalid type: %v", v)
	}

	if err != nil {
		return xerrors.Errorf("error in Set method: %w", err)
	}

	return nil
}

func (repo *{{ .RepositoryStructName }}) deleteBy{{ .KeyFieldName }}(v interface{}, {{ .KeyValueName }} {{ .KeyFieldType }}, {{ MetaJudgment }} ...DeleteOption) error {
	dr := repo.GetDocRef({{ .KeyValueName }})
{{ if .MetaFields }}
	if len(opts) > 0 && opts[0].Mode == DeleteModeSoft {
		subject, err := repo.get(v, dr)
		if err != nil {
			if status.Code(err) == codes.NotFound {
				return ErrNotFound
			}
			return xerrors.Errorf("error in get method: %w", err)
		}
		t := time.Now()
		subject.DeletedAt = &t
		if err = repo.update(v, subject); err != nil {
			return xerrors.Errorf("error in update method: %w", err)
		}
		return nil
	}
{{ end }}
	var err error

	switch x := v.(type) {
	case *firestore.Transaction:
		err = x.Delete(dr, firestore.Exists)
	case context.Context:
		_, err = dr.Delete(x, firestore.Exists)
	default:
		return xerrors.Errorf("invalid type: %v", v)
	}

	if err != nil {
		return xerrors.Errorf("error in Delete method: %w", err)
	}

	return nil
}

func (repo *{{ .RepositoryStructName }}) runQuery(v interface{}, query firestore.Query) ([]*{{ .StructName }}, error) {
	var iter *firestore.DocumentIterator

	switch x := v.(type) {
	case *firestore.Transaction:
		iter = x.Documents(query)
	case context.Context:
		iter = query.Documents(x)
	default:
		return nil, xerrors.Errorf("invalid type: %v", v)
	}

	defer iter.Stop()

	subjects := make([]*{{ .StructName }}, 0)

	for {
		doc, err := iter.Next()
		if err == iterator.Done {
			break
		}
		if err != nil {
			return nil, xerrors.Errorf("error in Next method: %w", err)
		}

		subject := new({{ .StructName }})

		if err := doc.DataTo(&subject); err != nil {
			return nil, xerrors.Errorf("error in DataTo method: %w", err)
		}

		subject.{{ .KeyFieldName }} = doc.Ref.ID
		subjects = append(subjects, subject)
	}

	return subjects, nil
}

func (repo *{{ .RepositoryStructName }}) list(v interface{}, req *{{ .StructName }}ListReq, q *firestore.Query) ([]*{{ .StructName }}, error) {
	if (req == nil && q == nil) || (req != nil && q != nil) {
		return nil, xerrors.New("either one should be nil")
	}

	query := func() firestore.Query {
		if q != nil {
			return *q
		}
		return firestore.Query{}
	}()

	if q == nil {
		ref := repo.GetCollection()
{{ $Meta := .MetaFields }}
{{- range $fi := .FieldInfos }}
{{- if eq $MetaName $fi.Field }}
{{- 	range $key, $value := $Meta }}
		if req.{{ $key }} != nil {
			for _, chain := range req.{{ $key }}.QueryGroup {
				if chain.IsSlice() && chain.Operator == OpTypeIn {
					if err := dedupe.Do(&chain.Value); err != nil {
						return nil, xerrors.Errorf("error in dedupe.Do method: %w", err)
					}
				}
				ref.Query = ref.Query.Where("{{ $key }}", chain.Operator, chain.Value)
			}
		}
{{- 	end }}
{{- else }}
{{- 	$IsSlice := HasSlice $fi.FieldType }}
{{- 	$IsMap := HasMap $fi.FieldType }}
		if req.{{ $fi.Field }} != nil {
{{- 		if eq $IsMap true }}
			for _, chain := range req.{{ $fi.Field }}.QueryGroup {
				items, ok := chain.Value.({{ $fi.FieldType }})
				if !ok {
					continue
				}
				for key, value := range items {
					if IsSlice(value) {
						ref.Query = ref.Query.Where("{{ $fi.FsTag }}."+key, OpTypeArrayContains, value)
						continue
					}
					ref.Query = ref.Query.Where("{{ $fi.FsTag }}."+key, chain.Operator, value)
				}
			}
{{- 		else if eq $IsSlice true }}
			for _, chain := range req.{{ $fi.Field }}.QueryGroup {
				if err := dedupe.Do(&chain.Value); err != nil {
					return nil, xerrors.Errorf("error in dedupe.Do method: %w", err)
				}
				ref.Query = ref.Query.Where("{{ $fi.FsTag }}", chain.Operator, chain.Value)
			}
{{- 		else }}
			for _, chain := range req.{{ $fi.Field }}.QueryGroup {
				if chain.IsSlice() && chain.Operator == OpTypeIn {
					if err := dedupe.Do(&chain.Value); err != nil {
						return nil, xerrors.Errorf("error in dedupe.Do method: %w", err)
					}
				}
				ref.Query = ref.Query.Where("{{ $fi.FsTag }}", chain.Operator, chain.Value)
			}
{{- 		end }}
		}
{{- 	end }}
{{- end }}

{{- if .MetaFields }}
{{ $metaPath := (index .MetaFields "DeletedAt").ParentPath }}
		if !req.IncludeSoftDeleted {
			ref.Query = ref.Query.Where("DeletedAt", OpTypeEqual, nil)
		}
{{- end }}

		query = ref.Query
	}

	return repo.runQuery(v, query)
}
